# MyDir - directory where this script is.
md=`dirname $0`
# LibDir - directory for library root.
ld=`dirname $md`

# Convert / to \.
wname() { echo $@ | sed -e "s|/|\\\\|g"; }

# Windows Directory Junction.
junction() {
  "$md/junction.exe" $@
}

notif() {
  echo $@
  echo "Press any key to continue or ctrl+c to abort."
  read
}

ctx() {
  echo $(dirname $1) | sed -E -e "s|[^/]+|..|g"
}

# : separated list of files/dirs that were added using *link functions.
setup_files=""

add_setup_file() {
  if [ "$setup_files" != "" ]; then
    setup_files="$setup_files:"
  fi
  setup_files="$setup_files$1"
}

setup_gitignore() {
  local self="$0"

  echo "Setting up .gitignore"

  local gi=.gitignore
  local gi_gen=.gitignore.generated
  cat "$gi" | awk \
    -v "gen_start=# Generated by $self" \
    -v "gen_end=# End of Generated by $self" \
    -v "clean=$opt_clean" \
    -v "setup_files=$setup_files" \
'
BEGIN {
  existing_found=0
  autogen_section=0
  path_sep=":"
  gitignore_sep="\n"
  gsub(path_sep, gitignore_sep, setup_files)
}
{
  if (index($0, gen_start) != 0) {
    if (clean == 0) { print $0 }
    autogen_section=1
    existing_found=1
  }
  if (autogen_section == 0) print $0
  else if (index($0, gen_end) != 0) {
    autogen_section=0
    if (clean == 0) {
      print setup_files
      print $0
    }
  }
}
END {
  if (clean == 0 && existing_found == 0) {
    print "\n"
    print gen_start
    print setup_files
    print gen_end
  }
}
' > $gi_gen
  mv -f "$gi_gen" "$gi"
}

# arg 1 - directory containing subfolders to merge
# arg 2 - target directory
mergedir() {
  local source="$ld/$1"
  local target="$ld/$2"

  echo "Merging $source to $target."

  mkdir -p "$target"
  for f in $(ls -1 "$source"); do
    local src="$source/$f"
    echo "$src"
    cp -a "$src"/* "$target/"
  done

  echo "Done merging $source to $target."
}

dirlink() {
  local name="$1"
  mkdir -p `dirname $name`

  if [[ "$OS" == *Windows* ]]; then
    junction -d "$name"
    test -e "$name" && {
      ls -la "$name"
      notif "Going to remove '$name'"
      rm -rfv "$name"
    }

    if [ "$opt_clean" != "1" ]; then
      while [ -n "$(junction "$name" "$ld/$name" | grep "Error opening")" ]; do
        echo "Directory $name is locked. Retrying in 1 second."
        sleep 1
        junction -d "$name"
      done
    fi
  else
    if [ -e "$name" -o -h "$name" ]; then
      ls -la "$name"
      notif "Going to remove '$name'"
      rm -rfv "$name"
    fi

    if [ "$opt_clean" != "1" ]; then
      ctx=$(ctx "$name")
      ln -s "$ctx/$ld/$name" "$name"
    fi
  fi

  add_setup_file "$name"
}

# Recursive dir link - find all dirs in given name and link them.
rdirlink() {
  local name="$1"
  for f in $(find "$ld/$name" -type d -mindepth 1 -maxdepth 1 | xargs); do
    local tname=`echo $f | sed -e "s|$ld/||"`
    dirlink "$tname"
  done
}

filelink() {
  local name="$1"
  mkdir -p `dirname $name`
  test -e "$name" && rm -rfv "$name"

  if [[ "$opt_clean" != "1" ]]; then
    if [[ "$OS" == *Windows* ]]; then
      fsutil hardlink create "$name" "$ld/$name"
    else
      local ctx=$(ctx $(dirname "$name"))
      ln -f "$ld/$name" "$name"
    fi
  fi

  add_setup_file "$name"
}

# Recursive file link - find all files in given name and link them.
rfilelink() {
  local name="$1"
  for f in $(find "$ld/$name" -type f | xargs); do
    local tname=`echo $f | sed -e "s|$ld/||"`
    filelink "$tname"
  done
}

opt_clean=0
for arg in "$@"; do
  if [ "$arg" == "clean" ]; then
    opt_clean=1
  fi
done

mergedir parts Assets
